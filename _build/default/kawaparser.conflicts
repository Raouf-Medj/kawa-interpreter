
** Conflict (shift/reduce) in state 76.
** Tokens involved: SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD
** The following explanations concentrate on token SUB.
** This state is reached from program after reading:

list(var_decl) list(class_def) MAIN BEGIN expression bop expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(var_decl) list(class_def) MAIN BEGIN list(instruction) END EOF 
                                          instruction list(instruction) 
                                          expression SEMI 
                                          (?)

** In state 76, looking ahead at SUB, shifting is permitted
** because of the following sub-derivation:

expression bop expression 
               expression bop expression 
                          . SUB 

** In state 76, looking ahead at SUB, reducing production
** expression -> expression bop expression
** is permitted because of the following sub-derivation:

expression bop expression // lookahead token appears because bop can begin with SUB
expression bop expression . 

** Conflict (reduce/reduce) in state 70.
** Tokens involved: TRUE THIS SUB NOT NEW LPAR INT IDENT FALSE
** The following explanations concentrate on token TRUE.
** This state is reached from program after reading:

list(var_decl) list(class_def) MAIN BEGIN NEW IDENT LPAR expression SUB

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(var_decl) list(class_def) MAIN BEGIN list(instruction) END EOF 
                                          instruction list(instruction) 
                                          expression SEMI 
                                          NEW IDENT LPAR list(expression) RPAR 
                                                         (?)

** In state 70, looking ahead at TRUE, reducing production
** bop -> SUB
** is permitted because of the following sub-derivation:

expression list(expression) 
expression bop expression // lookahead token appears because expression can begin with TRUE
           SUB . 

** In state 70, looking ahead at TRUE, reducing production
** uop -> SUB
** is permitted because of the following sub-derivation:

expression list(expression) 
           expression list(expression) 
           uop expression // lookahead token appears because expression can begin with TRUE
           SUB . 

** Conflict (shift/reduce) in state 65.
** Token involved: LPAR
** This state is reached from program after reading:

list(var_decl) list(class_def) MAIN BEGIN NEW IDENT LPAR expression DOT IDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(var_decl) list(class_def) MAIN BEGIN list(instruction) END EOF 
                                          instruction list(instruction) 
                                          expression SEMI 
                                          NEW IDENT LPAR list(expression) RPAR 
                                                         (?)

** In state 65, looking ahead at LPAR, shifting is permitted
** because of the following sub-derivation:

expression list(expression) 
expression DOT IDENT . LPAR list(expression) RPAR 

** In state 65, looking ahead at LPAR, reducing production
** mem -> expression DOT IDENT
** is permitted because of the following sub-derivation:

expression list(expression) // lookahead token appears because list(expression) can begin with LPAR
mem // lookahead token is inherited
expression DOT IDENT . 

** Conflict (shift/reduce) in state 53.
** Tokens involved: SUB REM OR NEQ MUL LT LE GT GE EQ DOT DIV AND ADD
** The following explanations concentrate on token SUB.
** This state is reached from program after reading:

list(var_decl) list(class_def) MAIN BEGIN uop expression

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(var_decl) list(class_def) MAIN BEGIN list(instruction) END EOF 
                                          instruction list(instruction) 
                                          expression SEMI 
                                          (?)

** In state 53, looking ahead at SUB, shifting is permitted
** because of the following sub-derivation:

uop expression 
    expression bop expression 
               . SUB 

** In state 53, looking ahead at SUB, reducing production
** expression -> uop expression
** is permitted because of the following sub-derivation:

expression bop expression // lookahead token appears because bop can begin with SUB
uop expression . 

** Conflict (shift/reduce) in state 45.
** Token involved: LPAR
** This state is reached from program after reading:

list(var_decl) list(class_def) MAIN BEGIN NEW IDENT LPAR NEW IDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
list(var_decl) list(class_def) MAIN BEGIN list(instruction) END EOF 
                                          instruction list(instruction) 
                                          expression SEMI 
                                          NEW IDENT LPAR list(expression) RPAR 
                                                         (?)

** In state 45, looking ahead at LPAR, reducing production
** expression -> NEW IDENT
** is permitted because of the following sub-derivation:

expression list(expression) // lookahead token appears because list(expression) can begin with LPAR
NEW IDENT . 

** In state 45, looking ahead at LPAR, shifting is permitted
** because of the following sub-derivation:

expression list(expression) 
NEW IDENT . LPAR list(expression) RPAR 
